// src/middleware.ts
import { NextResponse, type NextRequest } from "next/server";
import { getToken } from "next-auth/jwt";

// Only run where we actually need gating
export const config = {
  matcher: [
    "/admin/:path*",
    "/maintainer/:path*",
    "/api/admin/:path*",
    "/api/maintainer/:path*",
  ],
};

const RULES: Array<{ prefix: string; allow: Array<"ADMIN" | "MAINTAINER" | "USER"> }> = [
  { prefix: "/admin",          allow: ["ADMIN"] },
  { prefix: "/api/admin",      allow: ["ADMIN"] },
  { prefix: "/maintainer",     allow: ["ADMIN", "MAINTAINER"] },
  { prefix: "/api/maintainer", allow: ["ADMIN", "MAINTAINER"] },
];

export default async function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  // Read token generated by NextAuth (requires session: 'jwt')
  const token = await getToken({
    req,
    // Use the same secret as NextAuth
    secret: process.env.NEXTAUTH_SECRET,
  });

  // Require sign-in
  if (!token) {
    const url = new URL("/login", req.url);
    url.searchParams.set("callbackUrl", pathname);
    url.searchParams.set("reason", "signin_required");
    return NextResponse.redirect(url);
  }

  const role = ((token as any).role as string) ?? "USER";
  const rule = RULES.find((r) => pathname.startsWith(r.prefix));

  if (rule && !rule.allow.includes(role as any)) {
    const url = new URL("/403", req.url);
    url.searchParams.set("reason", "insufficient_role");
    return NextResponse.redirect(url);
  }

  return NextResponse.next();
}
